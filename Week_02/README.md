学习笔记
## HashMap 小结

### jdk1.8 版本，hashMap 改为了数组+链表+红黑树来实现。数组是实现 O(1)复杂度查询的基础，而链表和红黑树，是为了解决 hash 冲突。

#### 一.HashMap 的初始化函数
初始化无非涉及到，指定容量大小，负载因子，或者指定传入另一个 map，来创建元素相同的 hashMap。
容量大小：官方注释默认初始化必须为大小为 2 的整数次幂，这是因为元素的 key 放入 node 数组，是根据 key 的 hashcode 取余来确定，取余操作相比位运算还是慢，2 的整数次幂的容量，可以使用位运算代替取模运算，结果相同，提升效率。
负载因子：默认为 0.75，当元素个素达到负载因子指定的个数，可提前扩容，使得散列冲突的程度不会进一步提高。
#### 二.HashMap 的 put 操作
1.查询 node 数组是否为 null 或者 0，是的话进行初始化。
2.通过 key 计算 hash 值，从而确定插入到的数组索引。
3.判断该数组索引是否有元素，没有的话则加入，有的话则判断 hash，key 是否一致，一致则替换掉原来的节点。
4.否则出现 hash 冲突，则进一步需要定位插入位置。依据原先该位置的 node 类型，来确认调用红黑树的寻找方法，还是链表的寻找方法。  5.通过链表或者红黑树的寻找方法，来定位插入位置并插入。值得注意的是，若是链表方法，则后面需要判断该位置链表节点个数是否大于 8，大于 8 则将该链表转换为红黑树。
####  三.HashMap 的 get 操作
1.根据 key 计算 hash 值，从而数组的对应索引。
2.查看对应索引位置第一个节点的 key 是否相等，是的话直接返回。
3.不是的话，依据第一个节点的类型，从而判断只用红黑树寻找方法，还是链表寻找方法。
####  四.为何增加红黑树
1.红黑树是散列冲突发生后，对链表的一种优化，如果冲突很大，会导致链表很长，时间复杂度就为 O(n)
2.红黑树是自平衡的二叉搜索树，这样会使得查询时间减少为稳定的 O(lgn)
